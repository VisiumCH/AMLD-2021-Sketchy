"""
Tensorboard saves the embedding labels in 3 different files which contain the ordered labels, images and embeddings.
    - sprite.png: very large image containing the sketches and images next to each others
    - metadata.csv: each row contains the label of the associated sketch or images in sprite.png
    - tensors.tsv: earch row contains an embedding of the associated sketch or images in sprite.png
"""
import numpy as np
import pandas as pd
from PIL import Image
from sklearn.decomposition import PCA

from src.api.utils import base64_encoding


def read_tensor_tsv_file(fpath):
    """Read the tensors file:  earch row contains an embedding"""
    with open(fpath, "r") as f:
        tensor = []
        for line in f:
            line = line.rstrip("\n")
            if line:
                tensor.append(list(map(float, line.split("\t"))))
    return np.array(tensor, dtype="float32")


def read_class_tsv_file(fpath):

    with open(fpath, "r") as f:
        return [line.rstrip("\n") for line in f]


def get_class(tsv_path, sketch_emb):
    """
    Get a list of all labels
    Read the metadata file where each row contains an class
    Add "My Custom Sketch" if an sketch embedding is sent
    """
    # Classes of embeddings
    with open(tsv_path, "r") as f:
        classes = [line.rstrip("\n") for line in f]

    if type(sketch_emb) != bool:
        classes.append("My Custom Sketch")
    return classes


def get_tiles(im_path):
    """Crops the sprite.png at the appropriate locations to get the images and encode them in base 64"""
    im = Image.open(im_path)
    nb_rows = 23
    nb_images = 2 * 250
    full_size = im.size[0]
    size_img = int(full_size / nb_rows)
    tiles = [
        im.crop((x, y, x + size_img, y + size_img))
        for y in range(0, full_size, size_img)
        for x in range(0, full_size, size_img)
    ]
    tiles = tiles[:nb_images]
    tiles = [base64_encoding(tile) for tile in tiles]

    return tiles


def project_embeddings(tensors, n_components, sketch_emb):
    """Perform a PCA on the tensors and returns the projection"""
    if type(sketch_emb) != bool:
        # Add sketch embeddings
        sketch_emb = sketch_emb.detach().numpy()
        tensors = np.append(tensors, sketch_emb, axis=0)

    # PCA on tensors
    pca = PCA(n_components=n_components)
    pca.fit(tensors)
    return pca.transform(tensors)


def process_graph(embeddings_path, n_components, sketch_emb=False):
    """Retrieve all the data from the files generated by tensorboard"""
    # File names
    tensors_path = embeddings_path + "tensors.tsv"
    tsv_path = embeddings_path + "metadata.tsv"

    tensors = read_tensor_tsv_file(tensors_path)
    X = project_embeddings(tensors, n_components, sketch_emb)
    classes = get_class(tsv_path, sketch_emb)

    # Process in dataframe
    d = {"x": list(X[:, 0]), "y": list(X[:, 1]), "classes": classes}
    if n_components == 3:
        d["z"] = list(X[:, 2])
    df = pd.DataFrame(data=d)
    return df


def prepare_embeddings_data(df, nb_dimensions):
    """Sort the embeddings by classes"""
    df.sort_values(by=["classes"])
    class_set = sorted(list(set(df["classes"])))

    # Prepare data in object
    data = {}
    for _class in class_set:
        data[_class] = {}
        data[_class]["x"] = list(df[df["classes"] == _class]["x"])
        data[_class]["y"] = list(df[df["classes"] == _class]["y"])
        if nb_dimensions == 3:
            data[_class]["z"] = list(df[df["classes"] == _class]["z"])

    return data
